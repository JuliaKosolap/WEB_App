Комп’ютерний практикум 6

Тема: Алгоритми сортування. Методи сортування малих обсягів даних.
Мета роботи: Дослідження та порівняння алгоритмів сортування.

Теоретичні дані

Сортування вибором
Сортування вибором — простий алгоритм сортування лінійного масиву, на основі
вставок. Неефективний при сортуванні великих масивів, і в цілому, менш ефективним за
подібний алгоритм сортування включенням. Сортування вибором вирізняється більшою
простотою, ніж інші алгоритми, і в деяких випадках, вищою продуктивністю.
Алгоритм працює таким чином:
1. Знаходить у списку найменше значення
2. Міняє його місцями із першим значеннями у списку
3. Повторює два попередніх кроки, доки список не завершиться (починаючи з
наступної позиції)

Фактично, таким чином розділяється список на дві частини: перша (ліва) — повністю
відсортована, а друга (права) — ні.

Сортування вставками (включенням)
Сортування включенням — простий алгоритм сортування на основі порівнянь. На
великих масивах мало ефективний.
Алгоритм працює таким чином:
1. порівнюються другий та перший елемент вихідного масиву. Якщо порядок
між ними, в залежності від типу сортування (за зростанням чи за спаданням)
порушений, то перший елемент пересувається на одну позицію вправо.
Тепер відсортований масив складається з двох елементів.
2. наступний (третій, четвертий і так далі) елемент черзі порівнюється,
починаючи з кінця, з іншими елементами в уже відсортованому масиві.
Якщо порядок між порівнюваними елементами порушений, то вони
міняються місцями, якщо ні, то вставка нового елемента закінчена.
Відбувається перехід до п.1. ітерації.

Метод вибору чергового елементу з початкового масиву довільний; може
використовуватися практично будь-який алгоритм вибору. Зазвичай (і з метою отримання
стійкого алгоритму сортування), елементи вставляються за порядком їх появи у вхідному
масиві.

Сортування бульбашкою
Сортування обміном або сортування бульбашкою є простим алгоритмом сортування.
Алгоритм працює наступним чином:
1. у поданому наборі даних (списку чи масиві) порівнюються два сусідні елементи.
Якщо один з елементів, не відповідає критерію сортування (є більшим, або ж,
навпаки, меншим за свого сусіда), то ці два елементи міняються місцями;
2. прохід по списку продовжується доти, доки дані не будуть відсортованими.

Сортування підрахунком
Сортування підрахунком (англ. Counting sort) — алгоритм впорядкування, що
застосовується при малій кількості різних елементів (ключів) у масиві даних. Час його роботи
лінійно залежить як від загальної кількості елементів у масиві так і від
кількості різних елементів.

Алгоритм працює наступним чином:
1. підрахувати скільки разів кожен елемент (ключ) зустрічається в вихідному
масиві;

2. спираючись на ці дані вираховується на якому місці має стояти кожен елемент,
а потім за один прохід всі елементи розташовуються на своїх місцях.
Сортування Шелла
Сортува́ння Ше́лла — це алгоритм сортування, що є узагальненням сортування
включенням.
Алгоритм базується на принципах:
1. Сортування включенням ефективне для майже впорядкованих масивів.
2. Сортування включенням неефективне, тому що переміщує елемент тільки на
одну позицію за раз.
Тому сортування Шелла виконує декілька впорядкувань включенням, кожен раз
порівнюючи і переставляючи елементи, що розташовані на різній відстані один від одного.
Сортування Шелла не є стабільним методом.
Принцип роботи алгоритму:
1. На початку обираються m-елементів: d1, d2, ... dm причому d1 > d2 > ⋯ >
dm = 1, .
2. Потім виконується m впорядкувань методом включення, спочатку для
елементів, що стоять через d1, потім для елементів через d2 і т. д. до dm = 1 .
3. Ефективність досягається тим, що кожне наступне впорядкування вимагає
меншої кількості перестановок, оскільки деякі елементи вже стали на свої
місця.
4. Оскільки dm = 1 , то на останньому кроці виконується звичайне
впорядкування включенням всього масиву, а отже кінцевий масив буде
впорядкованим.
Швидке сортування
Швидке сортування (англ. Quick Sort) — алгоритм сортування, який не потребує
додаткової пам'яті і виконує у середньому O(nLog(n) операцій. Однак, у найгіршому випадку
робить O(n
2
) порівнянь. Так як, алгоритм використовує дуже прості цикли і операції, він
працює швидше за інші алгоритми, що мають таку ж асимптотичну оцінку складності.
Наприклад, зазвичай більш ніж удвічі швидший порівняно з сортуванням злиттям.
Алгоритм складається з трьох кроків:
1. Вибрати елемент з масиву. Має назву опорний.
2. Розбиття: перерозподіл елементів в масиві таким чином, що елементи менше
опорного розміщаються перед ним, а більше або рівні після.
3. Рекурсивно застосувати перші два кроки до двох підмасивів зліва і праворуч від
опорного елемента. Рекурсія не застосовується до масиву, в якому тільки один
елемент або відсутні елементи.

У ранніх реалізаціях, як правило, опорним вибирався перший елемент, що знижувало
продуктивність на відсортованих масивах. Для поліпшення ефективності може вибиратися
середній, випадковий елемент або (для великих масивів) медіана першого, середнього і
останнього елементів. Медіана всієї послідовності є оптимальним опорним елементом, але її
обчислення є занадто трудомістким для використання в сортуванні.
Для поліпшення продуктивності при великій кількості однакових елементів в масиві
може бути застосована процедура розбиття масиву на три групи: елементи менші опорного,
рівні йому і більше нього. Іноді його називають ще «товстим розбиттям».
Покращення
Покращення алгоритму спрямовані, в основному, на усунення або пом'якшення
вищезазначених недоліків, внаслідок чого всі їх можна розділити на три групи:
1. надання алгоритму стійкості,
2. усунення зменшення продуктивності спеціальним вибором опорного елемента,
3. захист від переповнення стека викликів через велику глибину рекурсії при невдалих
вхідних даних.
Проблема нестійкості вирішується шляхом розширення ключа вихідним індексом
елемента в масиві. У разі рівного розподілу основних ключів порівняння проводиться за
індексом, виключаючи, таким чином, можливість зміни взаємного положення рівних
елементів. Ця модифікація вимагає додаткового обсягу O (n) пам'яті і одного повного проходу
по масиву для збереження вихідних індексів.
Зменшення швидкості після невдалої спроби вхідних даних вирішується за двома
різними напрямками:
1. зниження ймовірності виникнення гіршого випадку шляхом спеціального вибору
опорного елемента;
2. застосування різних технічних прийомів, які забезпечують сталу роботу на
невдалих вхідних даних.
Для першого напряму:
1. Вибір середнього елемента. Усуває зменшення якості алгоритму для попередньо
відсортованих даних, але залишає можливість випадкової появи або навмисного
підбору «поганого» масиву.
2. Вибір медіани з трьох елементів: першого, середнього і останнього. В порівнянні з
вибором середнього елемента знижує ймовірність виникнення гіршого випадку,
3. Випадковий вибір. Імовірність випадкового виникнення гіршого випадку стає дуже
малою, а навмисний підбір - практично нездійсненним. Очікуваний час виконання
алгоритму сортування становить O (n lg n).
Недолік всіх ускладнених методів вибору опорного елемента -додаткові витрати
ресурсів, але вони не дуже великі.
Для вирішення проблеми відмови програми через велику глибину рекурсії
застосовують наступні методи:
1. При досягненні небажаної глибини рекурсії переходити на сортування іншими
методами, що не вимагають рекурсії. Прикладом такого підходу є алгоритм Introsort
або деякі реалізації швидкого сортування в бібліотеці STL. Можна помітити, що
алгоритм дуже добре підходить для такого роду модифікацій, так як на кожному
етапі дозволяє виділити безперервний відрізок вихідного масиву, призначений для
сортування, і те, яким методом буде відсортований цей відрізок, ніяк не впливає на
обробку інших частин масиву.
2. Модифікація алгоритму, що усуває одну гілку рекурсії: замість того, щоб після
поділу масиву викликати рекурсивно процедуру поділу для обох знайдених
підмасивів, рекурсивний виклик робиться тільки для меншого підмасиву, а більший
обробляється в циклі в межах цього ж виклику процедури. З точки зору
ефективності в середньому випадку різниці практично немає: витрати ресурсів на
додатковий рекурсивний виклик і на організацію порівняння довжин підмасивів і
циклу - приблизно одного порядку. Проте глибина рекурсії ні при яких обставинах

не перевищить log2n, а в гіршому випадку виродженого поділу вона взагалі буде не
більше 2 - вся обробка пройде в циклі першого рівня рекурсії. Застосування цього
методу не врятує від дуже великого зменшення продуктивності, але переповнення
стека не буде.
3. Розбиття масиву не на дві, а на три частини.

Завдання
1. Ознайомтесь з різновидами простих методів сортування та особливостями швидкого
метода сортування .
2. Напишіть програмні реалізації вирішення задачі, використовуючи прості алгоритми
сортування, за своїм варіантом для кожного з трьох випадків. При обиранні алгоритму
для 2 та 3 випадку звертайте увагу на особливості даних,
3. Напишіть програмну реалізацію вирішення задачі на основі швидкого методу
сортування за своїм варіантом для кожного з трьох випадків, для 3 випадку зверніть
увагу на особливості даних та застосуйте варіант покращення роботи алгоритму.
4. Проведіть серію експериментів для оцінки продуктивності реалізацій для всіх трьох
випадків для простих алгоритмів та швидкого сортування. Порівняйте отримані
результати .
5. За результатами експериментів зробіть висновки.
6. Зробіть висновки, чи отримано практичне підтвердження про продуктивність
сортування, що визначено теоретично; для яких даних досліджувані алгоритми
підходять якнайкраще, а у яких випадках використовувати їх недоцільно.
7. Дайте відповіді на контрольні питання.

Варіант 1
Жадібний леприкон зібрав всі можливі скарби в своїх печерах та вирішив їх розкласти
по скриня в тій же кількості, що і знаходив.. Майстер по виготовленню скринь робить їх
поступово від найменшої до найбільшої, тому вимагає надати йому відповідний перелік
розмірів скарбів. Леприкон дав йому відповідний перелік. Але поки майстер розмірковував,
гном пішов до сусіда та взяв частину його скарбів в мішечках та додав до своїх і знову пішов
до майстра. Сформував новий список скарбів. Майстер прийняв замовлення. Але сусідам
сподобалась така ідея і вони принесли свої скарби в мішечках леприкону, щоб розкласти по
скринях. Він побачив, що скарбів в мішечках часто повторювалася. Але знову пішов до
майстра з остаточним списком. Допоможіть йому дати майстру інформацію для кожного з
трьох випадків.
Варіант 2
Адмірал флоту вирішив провести профілактичні ремонтні роботи флоту. Але
працівники доку поставили умову прийняття кораблів в залежності від розміру (розмір
залежить від кількості матросів). Штаб сформував відповідний перелік. Поки формувався
список приплили ще кораблі, і виникла потреба переробити перелік. Список обновили. Але
інші адмірали вирішили доєднатися до таких робіт. З’ясувалося, що серед всіх кораблів
кількість матросів часто повторюється. Сформували остаточний перелік кораблів для ремонту.
Допоможіть їм сформувати списки для кожного з трьох випадків.
Варіант 3
Мережу зарядних пристроїв вирішили оновити. Але це треба робити поступово,
замінюючи пристрої в порядку збільшення їх потужності. Фахівці зробили перелік, але
з’ясувалося, що після цього додалася додаткова частина мережі, яку необхідно включити до
списку. Відбулося переформатування списку. Раптово компанія вирішила об’єднати всі
мережі. Виявилося, що в цій купі пристроїв є багато з однаковою потужністю. Зробили
остаточний перелік. Допоможіть сформувати перелік пристроїв для кожного з трьох випадків.

Склад звіту практичної роботи
– постановка задачі;
– опис швидкого алгоритму сортування;
– блок-схема реалізації, на якій виконано аналіз складності алгоритму;
– результати дослідження у вигляді графіків в координатах;
– висновки про доцільність використання кожного з алгоритмів для даних задачі
та про відповідність результатів експериментального дослідження аналітичним
оцінкам складності;
– відповіді на контрольні питання.